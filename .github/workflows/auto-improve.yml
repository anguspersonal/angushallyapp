name: Auto Code Improvements

on:
  schedule:
    # Runs every day at 2 AM UTC (adjust to your preference)
    - cron: '0 2 * * *'
  workflow_dispatch: # Allows manual triggering from GitHub UI

jobs:
  auto-improve:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # Get full history for better context

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Read improvement queue
        id: read-queue
        run: |
          # Read the first incomplete improvement from your queue file
          # Assumes you have a improvements.json file in the repo root
          if [ ! -f improvements.json ]; then
            echo "No improvements.json found"
            exit 0
          fi
          
          # Extract the first improvement that hasn't been completed
          IMPROVEMENT=$(jq -r '.improvements[] | select(.status != "completed") | @json' improvements.json | head -1)
          
          if [ -z "$IMPROVEMENT" ]; then
            echo "No pending improvements found"
            exit 0
          fi
          
          echo "improvement=$IMPROVEMENT" >> $GITHUB_OUTPUT
          echo "Found improvement: $IMPROVEMENT"

      - name: Generate code changes with Claude
        if: steps.read-queue.outputs.improvement != ''
        id: generate-changes
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          IMPROVEMENT: ${{ steps.read-queue.outputs.improvement }}
        run: |
          npm install @anthropic-ai/sdk
          
          cat << 'EOF' > generate_changes.js
          const Anthropic = require('@anthropic-ai/sdk');
          const fs = require('fs');
          
          const client = new Anthropic({
            apiKey: process.env.ANTHROPIC_API_KEY
          });
          
          async function generateChanges() {
            const improvement = JSON.parse(process.env.IMPROVEMENT);
            
            // Read relevant files for context
            const contextFiles = improvement.files || [];
            let context = '';
            for (const file of contextFiles) {
              if (fs.existsSync(file)) {
                context += `\n\n=== ${file} ===\n${fs.readFileSync(file, 'utf8')}`;
              }
            }
            
            const prompt = `You are helping implement the following improvement:

          Title: ${improvement.title}
          Description: ${improvement.description}
          Files to modify: ${improvement.files?.join(', ') || 'Not specified'}

          Current code context:${context}

          Please provide:
          1. The exact file changes needed (as a JSON array)
          2. A brief explanation of what you did

          Format your response as JSON:
          {
            "changes": [
              {
                "path": "path/to/file.js",
                "content": "full new content of the file"
              }
            ],
            "explanation": "Brief explanation of changes"
          }`;

            const message = await client.messages.create({
              model: 'claude-sonnet-4-20250514',
              max_tokens: 4000,
              messages: [{ role: 'user', content: prompt }]
            });
            
            const responseText = message.content[0].text;
            // Extract JSON from response (handle markdown code blocks)
            const jsonMatch = responseText.match(/```json\n([\s\S]*?)\n```/) || 
                             responseText.match(/({[\s\S]*})/);
            
            if (jsonMatch) {
              const result = JSON.parse(jsonMatch[1]);
              fs.writeFileSync('changes.json', JSON.stringify(result, null, 2));
              console.log('Changes generated successfully');
            } else {
              throw new Error('Could not parse JSON response from Claude');
            }
          }
          
          generateChanges().catch(err => {
            console.error('Error:', err);
            process.exit(1);
          });
          EOF
          
          node generate_changes.js

      - name: Apply changes and create branch
        if: steps.read-queue.outputs.improvement != ''
        id: apply-changes
        run: |
          # Parse the improvement to get metadata
          IMPROVEMENT='${{ steps.read-queue.outputs.improvement }}'
          TITLE=$(echo "$IMPROVEMENT" | jq -r '.title')
          BRANCH_NAME="auto-improve/$(echo "$TITLE" | tr '[:upper:]' '[:lower:]' | tr ' ' '-' | head -c 50)"
          
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          
          # Create a new branch
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout -b "$BRANCH_NAME"
          
          # Apply the changes
          if [ -f changes.json ]; then
            node << 'EOF'
          const fs = require('fs');
          const changes = JSON.parse(fs.readFileSync('changes.json', 'utf8'));
          
          for (const change of changes.changes) {
            // Ensure directory exists
            const dir = change.path.substring(0, change.path.lastIndexOf('/'));
            if (dir) {
              fs.mkdirSync(dir, { recursive: true });
            }
            fs.writeFileSync(change.path, change.content);
            console.log(`Updated ${change.path}`);
          }
          EOF
          fi
          
          # Commit changes
          git add .
          git commit -m "Auto-improvement: $TITLE"
          git push origin "$BRANCH_NAME"

      - name: Create Draft PR
        if: steps.apply-changes.outputs.branch_name != ''
        env:
          GH_TOKEN: ${{ github.token }}
          IMPROVEMENT: ${{ steps.read-queue.outputs.improvement }}
          BRANCH_NAME: ${{ steps.apply-changes.outputs.branch_name }}
        run: |
          TITLE=$(echo "$IMPROVEMENT" | jq -r '.title')
          DESCRIPTION=$(echo "$IMPROVEMENT" | jq -r '.description')
          
          # Read the explanation from Claude's response
          EXPLANATION=$(jq -r '.explanation' changes.json 2>/dev/null || echo "See commits for details")
          
          PR_BODY="## ðŸ¤– Auto-Generated Improvement

          **Original Request:**
          $DESCRIPTION

          **Changes Made:**
          $EXPLANATION

          ---
          *This PR was automatically generated. Review carefully before merging.*
          *To stop auto-improvements, disable the workflow in Actions settings.*"
          
          gh pr create \
            --title "ðŸ¤– Auto: $TITLE" \
            --body "$PR_BODY" \
            --base main \
            --head "$BRANCH_NAME" \
            --draft

      - name: Update improvement status
        if: success()
        run: |
          # Mark this improvement as "in_review" in the queue
          IMPROVEMENT='${{ steps.read-queue.outputs.improvement }}'
          TITLE=$(echo "$IMPROVEMENT" | jq -r '.title')
          
          # Update the status in improvements.json
          jq --arg title "$TITLE" \
             '(.improvements[] | select(.title == $title) | .status) = "in_review"' \
             improvements.json > improvements.json.tmp
          mv improvements.json.tmp improvements.json
          
          # Commit the updated queue
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git checkout main
          git add improvements.json
          git commit -m "Mark improvement as in_review: $TITLE" || true
          git push origin main || true
