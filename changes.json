{
  "changes": [
    {
      "path": "tests/services/payment.test.js",
      "content": "const PaymentService = require('../../src/services/payment');\nconst axios = require('axios');\n\n// Mock axios for HTTP requests\njest.mock('axios');\nconst mockedAxios = axios;\n\ndescribe('PaymentService', () => {\n  let paymentService;\n\n  beforeEach(() => {\n    paymentService = new PaymentService();\n    jest.clearAllMocks();\n  });\n\n  describe('processPayment', () => {\n    const validPaymentData = {\n      amount: 100.50,\n      currency: 'USD',\n      cardNumber: '4111111111111111',\n      expiryMonth: '12',\n      expiryYear: '2025',\n      cvv: '123',\n      customerEmail: 'test@example.com'\n    };\n\n    describe('Success cases', () => {\n      it('should process payment successfully with valid data', async () => {\n        const mockResponse = {\n          data: {\n            transactionId: 'txn_123456',\n            status: 'success',\n            amount: 100.50,\n            currency: 'USD'\n          }\n        };\n\n        mockedAxios.post.mockResolvedValueOnce(mockResponse);\n\n        const result = await paymentService.processPayment(validPaymentData);\n\n        expect(result).toEqual({\n          success: true,\n          transactionId: 'txn_123456',\n          amount: 100.50,\n          currency: 'USD'\n        });\n        expect(mockedAxios.post).toHaveBeenCalledWith(\n          expect.stringContaining('/payments'),\n          expect.objectContaining({\n            amount: 100.50,\n            currency: 'USD'\n          }),\n          expect.any(Object)\n        );\n      });\n\n      it('should handle different currencies', async () => {\n        const eurPayment = { ...validPaymentData, currency: 'EUR', amount: 85.25 };\n        const mockResponse = {\n          data: {\n            transactionId: 'txn_789',\n            status: 'success',\n            amount: 85.25,\n            currency: 'EUR'\n          }\n        };\n\n        mockedAxios.post.mockResolvedValueOnce(mockResponse);\n\n        const result = await paymentService.processPayment(eurPayment);\n\n        expect(result.success).toBe(true);\n        expect(result.currency).toBe('EUR');\n        expect(result.amount).toBe(85.25);\n      });\n    });\n\n    describe('Failure cases', () => {\n      it('should handle invalid card number', async () => {\n        const invalidPayment = { ...validPaymentData, cardNumber: '1234' };\n\n        const result = await paymentService.processPayment(invalidPayment);\n\n        expect(result).toEqual({\n          success: false,\n          error: 'Invalid card number',\n          code: 'INVALID_CARD'\n        });\n      });\n\n      it('should handle expired card', async () => {\n        const expiredCardPayment = {\n          ...validPaymentData,\n          expiryMonth: '01',\n          expiryYear: '2020'\n        };\n\n        const result = await paymentService.processPayment(expiredCardPayment);\n\n        expect(result).toEqual({\n          success: false,\n          error: 'Card has expired',\n          code: 'EXPIRED_CARD'\n        });\n      });\n\n      it('should handle insufficient funds', async () => {\n        const mockError = {\n          response: {\n            status: 402,\n            data: {\n              error: 'Insufficient funds',\n              code: 'INSUFFICIENT_FUNDS'\n            }\n          }\n        };\n\n        mockedAxios.post.mockRejectedValueOnce(mockError);\n\n        const result = await paymentService.processPayment(validPaymentData);\n\n        expect(result).toEqual({\n          success: false,\n          error: 'Insufficient funds',\n          code: 'INSUFFICIENT_FUNDS'\n        });\n      });\n\n      it('should handle invalid amount (negative)', async () => {\n        const negativeAmountPayment = { ...validPaymentData, amount: -50 };\n\n        const result = await paymentService.processPayment(negativeAmountPayment);\n\n        expect(result).toEqual({\n          success: false,\n          error: 'Amount must be greater than 0',\n          code: 'INVALID_AMOUNT'\n        });\n      });\n\n      it('should handle invalid amount (zero)', async () => {\n        const zeroAmountPayment = { ...validPaymentData, amount: 0 };\n\n        const result = await paymentService.processPayment(zeroAmountPayment);\n\n        expect(result).toEqual({\n          success: false,\n          error: 'Amount must be greater than 0',\n          code: 'INVALID_AMOUNT'\n        });\n      });\n\n      it('should handle missing required fields', async () => {\n        const incompletePayment = {\n          amount: 100,\n          currency: 'USD'\n          // missing card details\n        };\n\n        const result = await paymentService.processPayment(incompletePayment);\n\n        expect(result.success).toBe(false);\n        expect(result.error).toContain('Missing required field');\n        expect(result.code).toBe('MISSING_REQUIRED_FIELD');\n      });\n\n      it('should handle payment gateway rejection', async () => {\n        const mockError = {\n          response: {\n            status: 400,\n            data: {\n              error: 'Payment declined by issuer',\n              code: 'PAYMENT_DECLINED'\n            }\n          }\n        };\n\n        mockedAxios.post.mockRejectedValueOnce(mockError);\n\n        const result = await paymentService.processPayment(validPaymentData);\n\n        expect(result).toEqual({\n          success: false,\n          error: 'Payment declined by issuer',\n          code: 'PAYMENT_DECLINED'\n        });\n      });\n    });\n\n    describe('Edge cases and network issues', () => {\n      it('should handle network timeout', async () => {\n        const timeoutError = {\n          code: 'ECONNABORTED',\n          message: 'timeout of 5000ms exceeded'\n        };\n\n        mockedAxios.post.mockRejectedValueOnce(timeoutError);\n\n        const result = await paymentService.processPayment(validPaymentData);\n\n        expect(result).toEqual({\n          success: false,\n          error: 'Request timeout - please try again',\n          code: 'TIMEOUT'\n        });\n      });\n\n      it('should handle network connection error', async () => {\n        const networkError = {\n          code: 'ENOTFOUND',\n          message: 'getaddrinfo ENOTFOUND payment-gateway.com'\n        };\n\n        mockedAxios.post.mockRejectedValueOnce(networkError);\n\n        const result = await paymentService.processPayment(validPaymentData);\n\n        expect(result).toEqual({\n          success: false,\n          error: 'Network error - please check your connection',\n          code: 'NETWORK_ERROR'\n        });\n      });\n\n      it('should handle server error (5xx)', async () => {\n        const serverError = {\n          response: {\n            status: 500,\n            data: {\n              error: 'Internal server error'\n            }\n          }\n        };\n\n        mockedAxios.post.mockRejectedValueOnce(serverError);\n\n        const result = await paymentService.processPayment(validPaymentData);\n\n        expect(result).toEqual({\n          success: false,\n          error: 'Payment service temporarily unavailable',\n          code: 'SERVER_ERROR'\n        });\n      });\n\n      it('should handle very large amounts', async () => {\n        const largeAmountPayment = { ...validPaymentData, amount: 999999999.99 };\n        \n        const mockResponse = {\n          data: {\n            transactionId: 'txn_large',\n            status: 'success',\n            amount: 999999999.99,\n            currency: 'USD'\n          }\n        };\n\n        mockedAxios.post.mockResolvedValueOnce(mockResponse);\n\n        const result = await paymentService.processPayment(largeAmountPayment);\n\n        expect(result.success).toBe(true);\n        expect(result.amount).toBe(999999999.99);\n      });\n\n      it('should handle decimal precision correctly', async () => {\n        const preciseAmountPayment = { ...validPaymentData, amount: 12.345 };\n        \n        // Should round to 2 decimal places\n        const result = await paymentService.processPayment(preciseAmountPayment);\n        \n        if (mockedAxios.post.mock.calls.length > 0) {\n          const callArgs = mockedAxios.post.mock.calls[0][1];\n          expect(callArgs.amount).toBe(12.35); // Rounded to 2 decimal places\n        }\n      });\n\n      it('should handle malformed response from payment gateway', async () => {\n        const malformedResponse = {\n          data: {\n            // Missing required fields\n            status: 'unknown'\n          }\n        };\n\n        mockedAxios.post.mockResolvedValueOnce(malformedResponse);\n\n        const result = await paymentService.processPayment(validPaymentData);\n\n        expect(result).toEqual({\n          success: false,\n          error: 'Invalid response from payment gateway',\n          code: 'INVALID_RESPONSE'\n        });\n      });\n    });\n  });\n\n  describe('refundPayment', () => {\n    it('should process refund successfully', async () => {\n      const mockResponse = {\n        data: {\n          refundId: 'ref_123456',\n          status: 'success',\n          amount: 50.25,\n          originalTransactionId: 'txn_789'\n        }\n      };\n\n      mockedAxios.post.mockResolvedValueOnce(mockResponse);\n\n      const result = await paymentService.refundPayment('txn_789', 50.25);\n\n      expect(result).toEqual({\n        success: true,\n        refundId: 'ref_123456',\n        amount: 50.25,\n        originalTransactionId: 'txn_789'\n      });\n    });\n\n    it('should handle refund failure', async () => {\n      const mockError = {\n        response: {\n          status: 400,\n          data: {\n            error: 'Transaction not found',\n            code: 'TRANSACTION_NOT_FOUND'\n          }\n        }\n      };\n\n      mockedAxios.post.mockRejectedValueOnce(mockError);\n\n      const result = await paymentService.refundPayment('invalid_txn', 50);\n\n      expect(result).toEqual({\n        success: false,\n        error: 'Transaction not found',\n        code: 'TRANSACTION_NOT_FOUND'\n      });\n    });\n  });\n\n  describe('validatePaymentData', () => {\n    it('should return true for valid payment data', () => {\n      const validData = {\n        amount: 100,\n        currency: 'USD',\n        cardNumber: '4111111111111111',\n        expiryMonth: '12',\n        expiryYear: '2025',\n        cvv: '123',\n        customerEmail: 'test@example.com'\n      };\n\n      const result = paymentService.validatePaymentData(validData);\n      expect(result.isValid).toBe(true);\n      expect(result.errors).toEqual([]);\n    });\n\n    it('should return false for invalid email', () => {\n      const invalidData = {\n        amount: 100,\n        currency: 'USD',\n        cardNumber: '4111111111111111',\n        expiryMonth: '12',\n        expiryYear: '2025',\n        cvv: '123',\n        customerEmail: 'invalid-email'\n      };\n\n      const result = paymentService.validatePaymentData(invalidData);\n      expect(result.isValid).toBe(false);\n      expect(result.errors).toContain('Invalid email format');\n    });\n  });\n});"
    }
  ],
  "explanation": "Created comprehensive unit tests for the payment processing module covering success cases (valid payments, different currencies), failure cases (invalid cards, insufficient funds, missing fields, payment declines), and edge cases (network timeouts, connection errors, server errors, large amounts, decimal precision, malformed responses). Also included tests for refund functionality and payment data validation. The tests use Jest with axios mocking to simulate various payment gateway responses and network conditions."
}